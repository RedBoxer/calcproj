//=== подключаемые модули ===
#include "stdafx.h"
#include <iostream>
 
//=== глобальные переменные для удобства ===
int a,b; //от –2147483648 до    2147483647
char aa = -1,bb = -1; //чтобы сохранить знаки введеных чисел и не засорять ими промежуточный вывод
unsigned char b_array[]={0,0,0,0,0,0,0,0,0,0}; //будет использоваться для парсинга числа b на отдельные разряды. Потому берем минимальный тип char. А так как мы будем использовать только положительное число для работы (в дальнейшем это сделаем), то возьмем только НЕотрицательные, т.е. unsigned char
int tmp_array[]={0,0,0,0,0,0,0,0,0,0}; //при умножении integer на какое-либо число, может получиться результат больше integer и возникнет переполнение, потому сразу обговорим использование int (диапазон -9223372036854775808 .. 9223372036854775807)
 
//=== Функция: возведение 10 в степень. Для удобства. Можно воспользоваться функцией pow, но для этого придется подключать библиотеку cmath и не уверен, что она нормально будет работать с числами типа int
int ten(int value) //value - номер степени
{
    int tmp = 1; //так как будем получать степень 10, т.е. 10^0=1, 10^1=10 и т.д., то сразуопределим крайнее значение при возведении в нулевую степень.
 
    while (value != 0) 
    {
        tmp = tmp*10; //умножаем на 10 пока не кончится число степени
        value--; 
    }
    return tmp;
}
 
//=== функция расчета длины числа, необходимо для красивого вывода в столбцах ===
int lengthint(int value)
{
    int tmp=0;
    if (value == 0) tmp=1; //если число 0, то его длина тоже 1 и это крайний случай, который не подходиьт под дальнейший алгоритм
 
    while (value!=0) //если же изначально число не нуль, то делим его на 10 и считаем число разрядов
    {
        value = value / 10;
        tmp++;
    }
    return tmp; //возвращаем число разрядов
}
 
//=== читаем с клавиатуры два числа ===
void readnum(void)  //читаем с клавиатуры два числа
{
    printf ("Please write first number a="); //просим ввести с клавиатуры первое число
    scanf_s("%d",&a); //сохраняем его в переменную а. scanf_s используем потому что среда ругается на не безопасный ввод, возможно на более старых студиях (vs2008) можно и scanf юзать
    printf ("Please write second number b="); //просим ввести второе число
    scanf_s("%d",&b); //сохраняем в переменную b.
 
    //далее вывод двух чисел с учетом их длины и знака, опишу для одного подробно
    for(int i=0;i<20-lengthint(a);i++) printf (" "); //нам необходимо отступить слева определенное количество пробелов, чтобы сделать грамотный столбик. Мы отступаем 20-(длина числа а)
    if(a>=0) //если число положительное
    {
        printf (" "); //место под знак не нужно и мы заполняем его еще одним пробело
        aa = aa*-1; //у нас были переменные для сохранения информации для знака, это aa и bb. Изначально мы их задали сразу -1 и -1 соответственно. Если число положительное, здесь, когда мы провалились в условие, что число положительное, то мняем знак числа в переменной аа на положительный. Мне показалось так проще
    }
    printf ("%d\n",a); //выводим число а вместе со знаком
 
    for(int i=0;i<20-lengthint(b);i++) printf (" "); //аналогично предыдущему
    if(b>=0)
    {
        printf (" ");
        bb = bb*-1;
    }
    printf ("%d\n",b);
 
    a=abs(a); //так как мы будем промежуточный результат выводить без учета знака, то возьмем модули чисел. Заранее сохранив знаки в переменных аа и bb
    b=abs(b);
 
    printf ("  -------------------\n"); //подчеркивание после вывода чисел
}
 
//=== функция парсинга числа b по разрядам в массив.
void parsenum(int temp_b) //парсим значения поразрядно только для второго числа
{
    int num=0; //счетчик
    while (temp_b!=0) //пока число не кончилось во время его распила
    {
        b_array[num] = temp_b % 10; //сохраняем младший разряд
        temp_b = temp_b / 10; //удаляем его из числа b, деля на 10 целочисленно
        num++;
    }
}
 
//=== функция рассчета и всей производящейся математики ===
void math(void)
{
    int tmp=0; //переменная для хранения результата выполнения операций
 
    for(int i=0; i<lengthint(b);i++) //цикл расчета и вывода промежуочных результатов, пробигая по всей длине числа b
    {
        tmp_array[i] = (int)(a) * b_array[i]; //мы умножаем первое число a последовательно на каждый разряд числа b. Чтобы избежать переполнения int, расширим число a до int
        for(int j=0;j<21-lengthint(tmp_array[i])-i;j++) printf (" "); //как и было ранее, красивый вывод, только уже промежуточной строки с особенностью. Здесь нет проверки наличия знака, т.к. мы работаем с НЕотрицательными числами. Начальное значение сдвига строки 21, а не 20. Далее из него вычитаем длину выводимого числа (как и в случаях с а и b), а потом еще вычитаем разряд числа b, т.к. при умножении столбиком каждое следующее действие сдвигается на один разряд влево (не знаю ккак лучше это описать, но думаю и так понятно)
        printf ("%I64d\n",tmp_array[i]); //выводим промежуточное число. обычно для int используется форматированный вывод %d, но мы используем переменную int, а для нее вывод %I64d
    }
 
    printf ("  -------------------\n"); //когда все промежуточные результаты выведены, рисуем черту
 
    for(int i=0; i<lengthint(b);i++) //т.к. мы хотим показать, что все используемые промежуточные значения были полезны, мы же не выведем просто результат a*b, а проведем сложение, как стандартном случае правила сложения столбиком
    {
        tmp = tmp + (int)(tmp_array[i])*ten(i); //в tmp будем складывать все значения. Опять расширим до int, чтобы избежать переполнения int (т.е. в операции мы используем два числа int, то результат сначала будет int, а только потом он попадет в переменную int. А если одна из переменных принципиально будет int, а вторая int, то результат уже будет int на этапе умножения). Здесь используем нашу функцию, описанную выше - возведенеие 10 в степень (т.к. мы просто умножали разряд числа b на число a, настало время учитывать разряд числа b)
    }
    
    for(int i=0;i<20-lengthint(tmp);i++) printf (" "); //опять хитрый вывод результата (по аналогии с выводом a и b)
    tmp = tmp*aa*bb; //нужно вспомнить знак результата. Для этого нужно перемножитьднаки исходных множителей, для чего их и сохраняли
    if(tmp>=0) //стандартная уже для нас проверка: нужно ли оставить место под знак "-" при выводе числа
    {
        printf (" "); //если не нужно, то заполняем пробелом
    }
    printf ("%I64d\n",tmp);//выводим результат
}
 
int _tmain(int argc, _TCHAR* argv[])
{
    readnum(); //вызываем функцию чтения с клавиатуры чисел и их вывода
    
    parsenum(b); //вызов функции парсинга числа b
 
    math(); //вся обработка и вывод промежуточных результатов и итога
 
    system("pause"); //ждем any key
    return 0;
}